\section{Первая программа}

\vspace{-0.5cm}
\mylisting{testCIO.c}{}{Код первой программы. Один поток}{}

\img{2cm}{task011}{Результат работы первой программы. Один поток}{01}

\clearpage
\mylisting{testCIOths.c}{}{Код первой программы. Два потока}{}

\img{2cm}{task0121}{Результат работы первой программы. Два потока}{}

\vspace{-0.7cm}
\section*{Анализ результата}
\vspace{-0.2cm}

Системный вызов \texttt{open()} открывает файл "alphabet.txt" только для чтения
(\texttt{O\_RDONLY}), создает дескриптор открытого файла, соответствующий
индексу в таблице дескрипторов файлов, открытых процессом (массиве
\texttt{fd\_array } структуры \texttt{files\_struct}).  В данном случае
файловому дескриптору присваивается значение 3, так как значения 0, 1, 2 заняты
стандартными потоками ввода-вывода (\texttt{stdin}, \texttt{stdout},
\texttt{stderr}), а другие файлы процессом не открывались. Поле
\texttt{fd\_array[3]} указывает на \texttt{struct file}, связанную с
\texttt{struct inode}, соответствующую файлу "alphabet.txt".

Два вызова \texttt{fdopen()} стандартной библиотеки создают структуры
\texttt{FILE} (\texttt{fs1, fs2}), поле \texttt{\_fileno} которых
инициализируется файловым дескриптором, то есть значением 3.

Далее с помощью функции \texttt{setvbuf()} устанавливаются буферы для каждой из
структур \texttt{FILE}, задавая указатели на начало и конец буфера (указатель на
конец буфера рассчитывается через начало и размер буфера (20~байт), передаваемые
в качестве параметров в функцию \texttt{setvbuf()}) и тип буферизации (в данном
случае устанавливается полная буферизация).

В цикле поочередно для \texttt{fs1} и \texttt{fs2} вызывается функция
\texttt{fscanf()} стандартной библиотеки. Так как была установлена полная
буферизация, при первом вызове \texttt{fscanf()} буфер структуры \texttt{fs1}
будет полностью заполнен, то есть в него сразу запишутся 20~символов (буквы от
'A' до 't'). При этом поле \texttt{f\_pos} структуры \texttt{struct file}
установится на следующий символ ('u'), а в переменную \texttt{c} запишется
символ 'A', который и выведется на экран. При вызове \texttt{fscanf()} для
\texttt{fs2} в ее буфер запишутся оставшиеся символы (от 'u' до 'z'), так как
\texttt{fs2} ссылается на тот же дескриптор, что и структура \texttt{fs1}, а
поле \texttt{f\_pos} соответствующей структуры \texttt{struct file} было
изменено. В переменную \texttt{c} запишется символ 'u'.

При следующих вызовах \texttt{fscanf()} переменной \texttt{c} будут
присваиваться значения символов из буферов, и попеременно будут выводится
значения из каждого буфера. Когда символы в одном из буферов кончатся,
продолжится вывод символов только из одного буфера, а повторных заполнений
производится не будет, так как файл был полностью прочитан при первом заполнении
буфера \texttt{fs2}, что представлено на рисунке~\ref{img:01}.

В случае многопоточной реализации возможны различные варианты вывода, в
зависимости от того, какой поток первым вызовет \texttt{fscanf}. Возможна
ситуация аналогичная однопоточному варианту, с той поправкой, что порядок вывода
символов разными потоками может отличаться от запуску к запуску. Также возможно,
что в одном из потоков дважды произойдет заполнение буфера и второй поток ничего
не выведет.

\img{10cm}{task01}{Схема связей структур в первой программе}{}

\newpage
%================================
\section{Вторая программа}

\vspace{-0.5cm}
\mylisting{testKernelIO.c}{}{Код второй программы. Один поток}{}

\img{1.3cm}{task021}{Результат работы второй программы. Один поток}{}

\clearpage
\mylisting{testKernelIOths.c}{}{Код второй программы. Два потока}{}

\img{1.3cm}{task022}{Результат работы второй программы. Два потока}{}

\vspace{-0.7cm}
\section*{Анализ результата}
\vspace{-0.2cm}

В данной программе с помощью двух вызовов \texttt{open()} файл 'alphabet.txt'
дважды открывается только для чтения, и создаются два дескриптора открытого
файла (им присваиваются значения 3 и 4). При этом создаются две различные
структуры \texttt{struct file}, ссылающиеся на одну и ту же структуру
\texttt{struct~inode}. Так как структуры \texttt{struct file} разные и их поля
\texttt{f\_pos} изменяются независимо, то для каждого файлового дескриптора
произойдет полное чтение файла и каждый символ будет выведен два
раза.

При многопоточной реализации алфавит также будет выведен два раза, однако
порядок вывода символов при этом неизвестен.

\img{10cm}{task02}{Схема связей структур в второй программе}{}
\clearpage
\section{Третья программа}

\vspace{-0.5cm}
\mylisting{testWrite.c}{}{Код третьей программы. Один поток}{}

\img{1.3cm}{task0311}{Результат работы третьей программы. fs2 закрывается
	последним}{02}

\img{1.3cm}{task0312}{Результат работы третьей программы. fs1 закрывается
	последним}{03}

\img{9cm}{task03info}{Информация о состоянии открытых файлов}{}

\vspace{-0.7cm}
\section*{Анализ результата}
\vspace{-0.2cm}

В данной программе с помощью функции \texttt{fopen()} стандартной
библиотеки файл дважды открывается для записи. Так же как и во второй программе
создаются два файловых дескриптора (со значениями 3 и 4), на которые
ссылаются структуры \texttt{FILE} (\texttt{fs1, fs2}) . По умолчанию используется полная
буферизация, при которой запись в файл из буфера происходит либо когда буфер
заполнен, либо когда вызывается \texttt{fflush} или
\texttt{fclose}.

В данном случае запись в файл происходит при вызове \texttt{fclose()}. До
вызовов \texttt{fclose()} в цикле в файл записываются буквы латинского
алфавита с помощью передачи функции \texttt{fprintf()} то одного
дескриптора, то другого.

При вызове \texttt{fclose(fs1)} нечетные буквы алфавита записываются в файл.
При вызове \texttt{fclose(fs2)}, так как поле \texttt{f\_pos}
соответствующей структуры \texttt{struct file} не изменялось, запись в файл
произойдет с начала файла, и записанные ранее символы перезапишутся новыми
данными (четными буквами алфавита), что и показано на рисунке~\ref{img:02}.
Так как буферы содержали одинаковое количество символов, данные первой
записи были полностью утеряны. Если бы количество символов при второй
запись было меньше, чем при первой, то последние символы первой записи
сохранились бы.

Если бы сначала был вызов \texttt{fclose(fs2)}, а потом \texttt{fclose(fs1)},
то в файл записались нечетные буквы алфавита (рисунок~\ref{img:03}).

\mylisting{testWriteths.c}{}{Код третьей программы. Два потока}{}

\img{1.3cm}{task0311}{Результат работы третьей программы.\\Последним вызывается
	fclose в вспомогательном потоке}{}

\img{1.3cm}{task0312}{Результат работы третьей программы.\\Последним вызывается
	fclose в главном потоке}{}

\img{8.5cm}{task03}{Схема связей структур в третьей программе}{}

\section{Четвертая программа}

\vspace{-0.5cm}
\mylisting{testWriteK.c}{}{Код четвертой программы. Один поток}{}

\img{10cm}{task41}{Результат работы четвертой программы. Один поток}{01}

В программе файл дважды открывается на запись функцией open(). В системной 
таблице открытых файлов создаётся два дескриптора struct file, каждый из которых 
имеет собственный указатель f\_pos, но оба ссылаются на один
и тот же inode. С помощью системного вызова write() выполняется небуферизованный 
вывод. При изменении порядка вызова функций close() вывод программы не 
изменяется, так как вывод не буферизуется.

\clearpage
\mylisting{testWriteKths.c}{}{Код четвертой программы. Два потока}{}
При двух потоках ситуация аналогична предыдущей программе, только состав символов может меняться от запуска к запуску.

\img{10cm}{task43}{Результат работы четвертой программы. Два потока}{}

\img{10cm}{task02}{Схема связей структур в четвертой программе}{}