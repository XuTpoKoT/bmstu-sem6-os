\chapter{Билет №9}

\section*{Файловая система: процесс и файловые структуры связанные с процессом. Файлы и открытые файлы, связь структур, представляющих открытые файлы на разных уровнях. Системный вызов open() и библиотечная функция fopen(): параметры и флаги, определенные на функции open(). Реализация системного вызова open() в ядре Linux. Пример: файл открывается два раза системным вызовом open() для записи и в него последовательно записывается строка «аааааааааааа» по первому дескриптору и затем строка «вввв» по второму дескриптору, затем файл закрывается два раза. Показать, что будет записано в файл и пояснить результат.}

Процесс — это программа в стадии выполнения.
Процесс является единицей декомпозицией системы, именно ему выделяются ресурсы системы.

\section{Файл}
Файл --- важнейшее понятие в файловой подсистеме. Файл --- информация, хранимая во вторичной памяти или во вспомогательном ЗУ с целью ее сохранения после завершения отдельного задания или преодоления ограничений, связанных в объемом основного ЗУ.

Файл --- поименованная совокупность данных, хранимая во вторичной памяти (возможно даже целая). Файл --- каждая индивидуально идентифицированная единица информации.

Существует 2 ипостаси файла:
\begin{enumerate}
	\item файл, который лежит на диске;
	\item открытый файл (с которым работает процесс).
\end{enumerate}

Открытый файл — файл, который открывает процесс. Для такого файла создается дескриптор файла в таблице открытых файлов процесса (struct files\_struct). Но этого мало. Необходимо создать дескриптор открытого файла в системной таблице открытых файлов (struct file).

Файл != место на диске. В мире современной вычислительной техники файлы имеют настолько большие размеры, что не могут храниться в непрерывном физическом адресном пространстве, они хранятся вразброс (несвязанное распределение).

Файл может занимать разные блоки/сектора/дорожки на диске аналогично тому, как память поделена на страницы. В любой фрейм может быть загружена новая страница, как и файл. 

Также, важно понимать адресацию. 

Соответственно, система должна обеспечить адресацию каждого такого участка.

\begin{quote}
	ОС является загружаемой программой, её не называют файлом, но когда компьютер включается, ОС находится во вторичной памяти. Затем с помощью нескольких команд, которые находятся в ПЗУ, ОС (программа) загружается в ОЗУ. При этом выполняется огромное количество действий, связанных с управлением памятью, и без ФС это сделать невозможно. Любая ОС без ФС не может быть полноценной.
\end{quote}

Задача ФС --- обеспечивать сохранение данных и доступ к сохраненным данным (обеспечивать работу с файлами).

Чтобы обеспечить хранение файла и последующий доступ к нему, файл должен быть изолирован, то есть занимать некоторое адресное пространство, и это адресное пространство должно быть защищено. Доступ обеспечивается по тому, как файл идентифицируется в системе (доступ осуществляется по его имени).

ФС --- порядок, определяющий способ организации хранения, именования и доступа к данным на вторичных носителях информации.

\begin{quote}
	File management (управление файлами) --- программные процессы, связанные с общим управлением файлами, то есть с размещением во вторичной памяти, контролем доступа к файлам, записью резервных копий, ведением справочников (directory).
	
	Основные функции управления файлами обычно возлагаются на ОС, а дополнительные --- на системы управления файлами.
	
	Доступ к файлам: open, read, write, rename, delete, remove.
	
	Разработка UNIX началась с ФС. Без ФС невозможно создание приложений, работающих в режиме пользователя (сложно разделить user mode и kernel mode).
	
	Файловая подсистема взаимодействует практически со всеми модулями ОС, предоставляя пользователю возможность долговременного хранения данных, а также ОС возможность работать с объектами ядра.
\end{quote}

\section{struct file}

Существует 2 типа файлов --- файл, к-ый лежит на диске и открытый файл. Открытый файл -- файл, который открывает процесс

\textbf{Кратко}

struct file описывает открытый файл.

\textbf{Подробно}

Если файл просто лежит на диске, то через дерево каталогов можно увидеть это. 

Увидеть можно только подмонтированную ФС.

А есть открытые файлы --- файлы, с которыми работают процессы.

Открыть файл может только процесс. Если файл открывается потоком, то он в итоге все равно открывается процессом (как ресурс). Ресурсами владеет процесс.


\subsubsection{Таблицы открытых файлов}

Помимо таблицы открытых файлов процесса (есть у каждого процесса), в системе есть одна таблица на все открытые файлы (на которую ссылаются таблицы процессов).

Причем в этой таблице на один и тот же файл (с одним и тем же inode) мб создано большое кол-во дескрипторов открытых файлов, т.к. один и тот же файл мб открыт много раз. 

Каждое открытие файла с одним и тем же inode приведет к созданию дескриптора открытого файла.

При открытии файла его дескриптор добавляется:
\begin{enumerate}
    \item в таблицу открытых файлов процесса (struct file\_struct)
    \item в системную таблицу открытых файлов
\end{enumerate}

Каждый дескриптор struct file имеет поле f\_pos. При работе с файлами это надо учитывать.

Один и тот же файл, открытый много раз без соотв. способов взаимоискл. будет атакован, что приведет к потере данных.

\sout{Гонки при разделении файлов -- один и тот же файл мб открыт разными процессами.}

\subsubsection{Определение struct file}
\begin{lstlisting}
    struct file {
  struct path    f_path;
  struct inode    *f_inode;  /* cached value */
  const struct file_operations  *f_op;
        ...
  atomic_long_t    f_count;// кол-во жестких ссылок
  unsigned int     f_flags;
  fmode_t      f_mode;
  struct mutex    f_pos_lock;
  loff_t      f_pos;
  ...
  struct address_space  *f_mapping;
  ...
};
\end{lstlisting}
Как осуществляется отображение файла на физ. страницы? - дескриптор открытого файла имеет указатель на inode (файл на диске).

\textbf{Связь между struct file и struct file operations}

Файл должен быть открыт. Соответственно для открытого файла должен быть создан дескриптор. В этом дескрипторе имеется указатель на struct file\_operations. Это либо стандартные (установленные по умолчанию) операции на файлах для конкретной файловой системы, либо зарегистрированные разработчиком (собственные функции работы с файлами собственной файловой системы).

\begin{lstlisting}
	struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	...
	int (*open) (struct inode *, struct file *);
	...
	int (*release) (struct inode *, struct file *);
	...
} __randomize_layout;
\end{lstlisting}

\section{Связи структур}

\textbf{Связи структур при выполнении системных вызовов}
\begin{table}[H]
  \centering
  \begin{tabular}{p{1\linewidth}}
    \centering
    \includegraphics[width=0.8\linewidth]{./images/systemcalls_connect.pdf}
  \end{tabular}
\end{table}

\textit{Воспоминания о пояснениях}

Указатель f\_mapping показывает связь структур, описывающих файлы в системе с памятью. Также в struct inode есть поле i\_mapping.

struct super\_block содержит список inode (s\_inodes). struct inode содержит указатель на соответствующий inode в списке (i\_sb\_list).

Любая файловая система имеет корневой каталог, а именно от корневого каталога формируется путь к файлу для конкретной файловой системы.

Отправная точка — системные вызовы (read, write, lseek, ...). Здесь нет open(), так как он открывает файл, а использование функций read, write, lseek возможно только при работе с открытым файлом.

\textbf{Связи структур относительно процесса}
\par Теперь пойдем от процесса: Отправная точка -- \textbf{struct task\_struct};
В \textbf{struct task\_struct} есть 2 указателя: 
\begin{itemize}
\item на \textbf{struct fs\_struct} (*fs); - Любой процесс относится к какой-то файловой системе
\item на \textbf{struct files\_struct} (*files) -- дескриптор, описывающий файлы, открытые процессом (Любой процесс имеет собственную таблицу открытых файлов).
\end{itemize}

\begin{table}[H]
  \centering
  \begin{tabular}{p{1\linewidth}}
    \centering
    \includegraphics[width=0.8\linewidth]{./images/struct_connect_proc.pdf}
  \end{tabular}
\end{table}

\textit{Воспоминания о зарождении процесса}

\par Каждый процесс до того, как он был запущен, был файлом и принадлежал некоторой \textit{вайбовой} системе, поэтому в \textbf{struct task\_struct} имеется указатель на фс, которой принадлежит файл программы, и указатель на таблицу открытых файлов процесса.
\par Очевидно, что \textbf{struct files\_struct} содержит массив дескрипторов открытых файлов (0,1,2,3,4,...).
\par При этом 
\begin{itemize}
\item 0 -- stdin
\item 1 -- stdout
\item 02-- stderr
\item 03 -- скорая помощь
\end{itemize}
\par Эти файлы открываются для процесса автоматически (файловые дескрипторы для этих файлов создаются автоматически).
\par Когда мы открываем файл, он может получить дескриптор, после этих трех (например, 3,4,5 и тд)
\par Всего в этой таблице может быть 256 дескрипторов.
\par \textbf{struct vfs\_mount} заполняется, когда файловая система монтируется. Имя -- указатель на \textbf{struct qstr}.
\par В \textbf{struct super\_block} есть указатель на \textbf{struct super\_operations} (s\_op) и на root (s\_root), так как корневой каталог (точка монтирования) должен быть создан, чтобы иметь возможность смонтировать файловую систему.

\textbf{Связи структур из лабы на буферы}

\textit{1 open, 2 fdopen, буферизация, читали 20 и 6 байт, выводили на экран}
\begin{table}[H]
  \centering
  \begin{tabular}{p{1\linewidth}}
    \centering
    \includegraphics[width=0.8\linewidth]{./images/scheme1.pdf}
  \end{tabular}
\end{table}

\textit{2 open, 2 дескриптора, без буферизации, посимвольно читали и выводили}
\begin{table}[H]
  \centering
  \begin{tabular}{p{1\linewidth}}
    \centering
    \includegraphics[width=0.8\linewidth]{./images/scheme2.pdf}
  \end{tabular}
\end{table}

\textit{2 open, без буферизации и с ней, шли от а до з писали по очереди, 2 разных дескриптора, свои фпоз, записался либо по последнему фклоуз (при буф), либо по райт (посимвольно затирается без буф)}
\begin{table}[H]
  \centering
  \begin{tabular}{p{1\linewidth}}
    \centering
    \includegraphics[width=0.8\linewidth]{./images/scheme3.pdf}
  \end{tabular}
\end{table}

\section{Системный вызов open()}
Системный вызов open() открывает файл, определённый $pathname$.

\textbf{Возвращаемое значение}

open() возвращает файловый дескриптор~---~небольшое неотрицательное целое число, которое является ссылкой на запись в системной таблице открытых файлов и индексом записи в таблице дескрипторов открытых файлов процесса. Этот дескриптор используется далее в системных вызовах read(), write(), lseek(), fcntl() и т.д. для ссылки на открытый файл. В случае успешного вызова будет возвращён наименьший файловый дескриптор, не связанный с открытым процессом файлом.

В случае ошибки возвращается -1 и устанавливается значение errno.

\textbf{Параметры}

$pathname$~---~имя файла в файловой системе. $flags$~---~режим открытия файла~---~один или несколько флагов открытия, объединенных оператором побитового ИЛИ. 

\begin{lstlisting}
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open (const char *pathname, int flags);
int open (const char *pathname, int flags, mode_t mode);
\end{lstlisting}

2 варианта open():
\begin{enumerate}
    \item Если ф-ция open предназначени для работы с существующим файлом, то это ф-ция вызывается с 2 параметрами.
    \item Если пользователь желает создать файл и использует флаг O\_CREATE или O\_TMPFILE, то он должен указать 3-й пар-р --- mode; Если эти флаги не указаны, то 3-й параметр игнорируется.
\end{enumerate}

Так, можно открыть существующий файл, а можно открыть новый (создать) файл. Создать файл --- создать inode.


\section{Основные флаги. Флаг CREATE}

\begin{quote}

O\_CREAT

(если файл не существует, то он будет создан. Владелец (идентификатор пользователя) файла устанавливается в значение эффективного идентификатора пользователя процесса. Группа (идентификатор группы) устанавливается либо в значение эффективного идентификатора группы процесса, либо в значение идентификатора группы родительского каталога (зависит от типа файловой системы, параметров подсоединения (mount) и режима родительского каталога, см. например, параметры подсоединения bsdgroups и sysvgroups файловой системы ext2, как описано в руководстве mount(8)).);

O\_EXCL

(Если он используется совместно с O\_CREAT, то при наличии уже созданного файла вызов open завершится с ошибкой. В этом состоянии, при существующей символьной ссылке не обращается внимание, на что она указывает.);

O\_EXCL

(Оно не работает в файловых системах NFS, а в программах, использующих этот флаг для блокировки, возникнет "race condition". Решение для атомарной блокировки файла: создать файл с уникальным именем в той же самой файловой системе (это имя может содержать, например, имя машины и идентификатор процесса), используя link(2), чтобы создать ссылку на файл блокировки. Если link() возвращает значение 0, значит, блокировка была успешной. В противном случае используйте stat(2), чтобы убедиться, что количество ссылок на уникальный файл возросло до двух. Это также означает, что блокировка была успешной);

O\_APPEND

(Файл открывается в режиме добавления. Перед каждой операцией write файловый указатель будет устанавливаться в конце файла, как если бы использовался lseek); O\_APPEND (может привести к повреждению файлов в системе NFS, если несколько процессов одновременно добавляют данные в один файл. Это происходит из-за того, что NFS не поддерживает добавление в файл данных, поэтому ядро на машине-клиенте должно эмулировать эту поддержку);

\end{quote}

\textbf{O\_RDONLY} - открыть файл только на чтение

\textbf{O\_WRONLY} - открыть файл только на запись

\textbf{O\_RDWR}- открыть файл для чтения и записи

\textbf{O\_PATH} - получить лишь файловый дескриптор (сам файл не будет открыт). \textit{ Будет возвращен дескриптор struct file(он уже  существует, мы его не создаем), при этом сам файл не открывается. Если флаг не установлен, то будет организован цикл по всем эл-там пути и вызвана ф-ция do\_open, которая открывает файл, т.е. создает дескриптор (инициализирует поля struct file).}


\textbf{O\_TMPFILE} - создать неименованный временный обычный файл. Предполагает создание временного файла. Если он установлен, будет вызвана ф-ция do\_tmpfile.

\textbf{O\_APPEND} - установить смещение f\_pos на конец файла.


\textbf{O\_CREAT} - если файл не существует, то он будет создан, id владельца и группы файла устанавливаются действующим id пользователя и группы процесса.

Младшие 12 бит значения режима доступа к файлу устанавливается равными значению аргумента mode, модифицированному следующим образом:

- Биты, соответствующие единичным битам маски режима создания файлов текущего процесса устанавливаются в 0

- Бит навязчивости устанавливается равным в 0

Если установлен флаг O\_CREAT и указано несуществующее имя файла (система это контролирует), то д.б. создан inode.

\textbf{O\_TRUNC} - если файл уже существует, он является обычным файлом и заданный режим позволяет записывать в этот файл, то его размер будет установлен в 0 (вся информация будет удалена). Режим доступа и владелец не меняются.

\textbf{O\_EXCL }- если установлен O\_EXCL и O\_CREAT и указано имя существующего файла (файл уже существует), то open вернёт ошибку. Библиотечная функция fopen этого не делает.

\textbf{O\_LARGEFILE} - позволяет открывать файлы, размер которых не может
быть представлен типом off\_t (long). Для установки должен быть указан макрос 
\_LARGEFILE64\_SOURCE.

\textbf{O\_CLOEXEC} - устанавливает флаг \textit{close-on-exec} для нового файлового дескриптора, указание этого флага позволяет программе избегать дополнительных операций fcntl F\_SETFD для установки флага FD\_CLOEXEC.


\textbf{O\_EXEC} - открыть только для выполнения (результат не определен при открытии директории).

Режим (права доступа): 

Если мы создаем новый файл, то мы должны указать права доступа к файлу. 

Для режима предусмотрены константы (для пользователя/группы):

-  SR\_IRWXU / SR\_IRWXG - права доступа на чтение, запись и исполнение

- SR\_IRUSR / SR\_IRGRP - права на чтение

- SR\_IWUSR / SR\_IWGRP - права на запись

- SR\_IXUSR / SR\_IXGRP - права на исполнение

\section{Реализация системного вызова open() в системе – действия в ядре}
open(), как и любой системный вызов переводит систему в режим ядра.

Сначала ищется свободный дескриптор в struct files\_struct (в массиве дескрипторов открытых файлов процесса), потом при опр. усл-ях создается дескриптор открытого файла в системной таблице открытых файлов, затем при опрю усл-ях создается inode.

\section{Библиотечная функция fopen()}

fopen() — это функция стандартной библиотеки stdio.h. Стоит отметить, что стандартный ввод-вывод буферизуется.
\begin{lstlisting}
FILE *fopen(const char *fname, const char *mode);
\end{lstlisting}

Функция fopen() открывается файл, имя которого указано аргументом fname и возвращает связанный с ним указатель. Тип операций, разрешенных над файлом, определяется аргументом mode.

\textbf{Возможно}, стоит добавить, что функции библиотеки stdio.h могут работать с форматированныит данными.

\section{Реализация системного вызова open() в ядре Linux}
open(), как и любой системный вызов переводит систему в режим ядра.

Сначала ищется свободный дескриптор в struct files\_struct (в массиве дескрипторов открытых файлов процесса), потом при опр. усл-ях создается дескриптор открытого файла в системной таблице открытых файлов, затем при опрю усл-ях создается inode.

\section{SYSCALL\_DEFINE3(open,…)}
В режиме ядра есть syscall table.

В системе есть 6 макросов -- syestem call macro. У всех 1 параметр -- имя сист. вызова.

С open() работает третий:

SYSCALL\_DEFINE3(open, const char \_\_user *filename, int flags, mode\_t mode);

\begin{lstlisting}
    SYSCALL_DEFINE3(open, const char __user *filename, int flags, mode_t mode)
    {
    if (force_o_largefile())
        flags |= O_LARGEFILE;
    return do_sys_open(AT_FDCWD, filename, flags, mode)
    }
\end{lstlisting}

filename -- имя файла, которое передается из пространства пользователя в пр-во ядра. Это нельзя сделать напрямую. Впоследствии будет вызвана ф-ция str\_copy\_from\_user() для передачи имени файла в ядро (это делается последовательно в результате ряда вызовов функций).

В макросе выполняется проверка того, какая у нас система: если 64-разр., то в ней есть большие файлы (largefile), и флаг O\_LARGEFILE добавляется к флагам, к-ые были установлены.

Основная задача макроса -- вызов ф-ции ядра do\_sys\_open()

\section{do\_sys\_open()}
\begin{lstlisting}
    long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
  struct open_flags op;
  int fd = build_open_flags(flags, mode, &op);
  struct filename *tmp;

  if (fd)
    return fd;

  tmp = getname(filename);
  if (IS_ERR(tmp))
    return PTR_ERR(tmp);

  fd = get_unused_fd_flags(flags);//обертка __alloc_fd()
  if (fd >= 0) {
    struct file *f = do_filp_open(dfd, tmp, &op);
    if (IS_ERR(f)) {
      put_unused_fd(fd);
      fd = PTR_ERR(f);
    } else {
      fsnotify_open(f);
      fd_install(fd, f);
    }
  }
  putname(tmp);
  return fd;
}
\end{lstlisting}

\section{do\_filp\_open()}
Основную работу по открытию файла и связанные с этим действия выполняет ф-ция do\_filp\_open().

\textit{struct filename и struct open\_flags --- эти структуры инициализированны в результате работы функций, которые были вызваны ранее}

\begin{lstlisting}
    struct file *do_filp_open(int dfd, struct filename *pathname,
    const struct open_flags *op)
{
  struct nameidata nd; // внутренняя служебная структура
  int flags = op->lookup_flags;
  struct file *filp;

  set_nameidata(&nd, dfd, pathname);
  filp = path_openat(&nd, op, flags | LOOKUP_RCU);
  if (unlikely(filp == ERR_PTR(-ECHILD)))
    filp = path_openat(&nd, op, flags);
  if (unlikely(filp == ERR_PTR(-ESTALE)))
    filp = path_openat(&nd, op, flags | LOOKUP_REVAL);
  restore_nameidata();
  return filp;
}
\end{lstlisting}

\section{build\_open\_flags()}
Задачи ф-ции build\_open\_flags() -- инициализация полей struct open\_flags на основе флагов, указанных пользователем

В этой функции анализируются все флаги.

\section{get\_unused\_fd\_flags()}
Можно предположить, что ф-ция get\_unused\_fd\_flags должна найти неиспользуемый файловый дескриптор в таблице дескрипторов открытых файлов для того, чтобы выделить его, и open() мог его вернуть.

\section{alloc\_fd()}
При этом ф-ция \_\_alloc\_fd() использует spin-lock'и, т.к. эти действия могут выполнять несколько процессов/потоков.

\section{getname()}
Ф-ция getname() вызывает get\_name\_flags(), которая копирует имя файла из пр-ва пользователя в пр-во ядра. При этом используется ф-ция str\_copy\_from\_user().

Для любого процесса файловые дескрипторы 0, 1, 2 (stdin, stdout, stderr) занимаются автоматически, но для этих дескрипторов необходимо проделать все действия так же, как при вызове open() в приложении.


\section{set\_nameidata()}
Ф-ция set\_nameidata инициализирует поля struct nameidata.

\section{path\_openat()}
Функция path\_openat возвращает инициализированный дескриптор открытого файла (struct file)

\underline{1-й вызов}

'Быстрый проход': игнорируются некоторые проверки. Это проход по всем флагам и выполнение соотв. анализа.

\underline{2-й вызов}

'Обычный'(если быстрый проход вернул ошибку).

\underline{3-й вызов}

Для файлов NFS (network filesystem).

В NFS не работает флаг O\_APPEND, возникают гонки. O\_APPEND позволяет дописывать данные в конец файла без потери данных в нем.

Гонки при разделении файлов --- один и тот же файл мб открыт разными процессами.

\begin{lstlisting}
    static struct file *path_openat(struct nameidata *nd,
      const struct open_flags *op, unsigned flags)
{
  const char *s;
  struct file *file;
  int opened = 0;
  int error;

  file = get_empty_filp();
  if (IS_ERR(file))
    return file;

  file->f_flags = op->open_flag;

  if (unlikely(file->f_flags & __O_TMPFILE)) {
    error = do_tmpfile(nd, flags, op, file, &opened);
    goto out2;
  }

  if (unlikely(file->f_flags & O_PATH)) {
    error = do_o_path(nd, flags, file);
    if (!error)
      opened |= FILE_OPENED;
    goto out2;
  }

  s = path_init(nd, flags);
  if (IS_ERR(s)) {
    put_filp(file);
    return ERR_CAST(s);
  }
  while (!(error = link_path_walk(s, nd)) &&
    (error = do_last(nd, file, op, &opened)) > 0) {
    nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
    s = trailing_symlink(nd);
    if (IS_ERR(s)) {
      error = PTR_ERR(s);
      break;
    }
  }
  terminate_walk(nd);
out2:
  if (!(opened & FILE_OPENED)) {
    BUG_ON(!error);
    put_filp(file);
  }
  if (unlikely(error)) {
    if (error == -EOPENSTALE) {
      if (flags & LOOKUP_RCU)
        error = -ECHILD;
      else
        error = -ESTALE;
    }
    file = ERR_PTR(error);
  }
  return file;
}

\end{lstlisting}

\textit{
Функции ядра специфицированы, но не стандартизованы (в отличие от сист. вызовов, которые стандартизованы POSIX). Поэтому функции и структуры ядра переписываются.}

\textit{
Для того, чтобы определить, существует ли файл, нужно пройти по цепочке dentry (задействуется struct dentry).}

\section{Пример}
\begin{lstlisting}
#include <fcntl.h>  // O_RDWR
#include <unistd.h> // write, close
#include <string.h> // strlen

int main()
{
  int fd1 = open("text.txt", O_RDWR);
  int fd2 = open("text.txt", O_RDWR);

  char *data1 = "aaaaaaaaaaaa";
  char *data2 = "bbbb";

  write(fd1, data1, strlen(data1));
  write(fd2, data2, strlen(data2));

  close(fd1);
  close(fd2);

  return 0;
}
\end{lstlisting}

\textbf{Результат:} bbbbaaaaaaaa.

В данной программе с помощью системного вызова open() создаются два файловых дескриптора struct file одного и того же файла, то есть создаются две записи в системной таблице открытых файлов. Каждый дескриптор будет иметь своё смещение f\_pos. Поэтому каждая строка будет записана в начало файла.

\textbf{Результат:} Данные затерлись (произошла потеря данных).


