\chapter{Билет №15}

\section*{Загружаемые модули ядра. Структура загружаемых модулей. Информация о процессах, доступная в ядре. Пример вывода информации о запущенных процессах, символ current (лаб. раб.). Взаимодействие загружаемых модулей в ядре. Экспорт данных. Пример взаимодействия модулей (лаб. раб.). Функция printk() – назначение и особенности. Регистрация функций работы с файлами. Пример заполненной структуры. Передача данных из пространства ядра в пространство пользователя и из пространства пользователя в пространство ядра. Примеры из лабораторный работ.}

\section{Загружаемые модули ядра}
Linux имеет монолитное ядро. Чтобы внести в него изменения, надо его перекомпилировать (патчи). Это опасно, так как можно получить неработающее ядро. В Unix/Linux можно вносить изменения без перекомпиляции, с помощью загружаемых модулей ядра. Это ПО, которое пишется по определенным шаблонам.

\section{Структура загружаемых модулей}

Загружаемые модули ядра имеют как минимум две точки входа~---~\texttt{init} и \texttt{exit}. Имена точек входа передаются с помощью макроса:

\begin{lstlisting}
module_init(<точка входа init>)
module_exit(<точка входа exit>)
\end{lstlisting}

Макрос \texttt{module\_init} служит для регистрации функции инициализации модуля. Макрос принимает в качестве параметра указатель на соответствующую функцию. В результате эта функция будет вызываться при загрузке модуля в ядро. Функция инициализации:

\begin{lstlisting}
int func_init(void);
\end{lstlisting}

Если функция инициализации завершилась успешно, то возвращается 0. В случае ошибки возвращается ненулевое значение.

\begin{quote}
	Как правило, функция инициализации предназначена для запроса ресурсов, выделения памяти под структуры данных и т. п. Так как функция инициализации редко вызывается за пределами модуля, ее обычно не нужно экспортировать и можно объявить с ключевым словом \texttt{static}.
\end{quote}

Макрос \texttt{module\_exit} служит для регистрации функции, которая вызывается при выгрузке модуля из ядра. Обычно эта функция выполняет задачу освобождения занятых ресурсов. Функция выгрузки:

\begin{lstlisting}
void func_exit(void);
\end{lstlisting}

Загружаемые модули ядра~---~многовходовые программы. Две точки входа всегда обязательны~---~\texttt{init} и \texttt{exit}.

Некоторые точки могут вызываться из \texttt{init}, тогда их можно будет назвать точками входа с натяжкой.

\begin{quote}
	Сама ОС имеет много точек входа (системные вызовы, исключения, аппаратные прерывания), но в каждом случае вызываются разные коды ядра (системный вызов~$\rightarrow$~функция ядра, то есть интерфейс между kernel и user mode).
\end{quote}

\subsection{Пример модуля ядра <<Hello World>>}

\begin{lstlisting}
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

// Указание лицензии обязательно
MODULE_LICENSE("GPL");

static int __init my_module_init()
{
    printk(KERN_INFO "Hello, World!\n");
    return 0;
}

static void __exit my_module_exit()
{
    printk(KERN_INFO "Stop\n"); // print kernel - пишет в системный лог, доступна в ядре.
    // KERN_INFO - уровень протоколирования. Запятая между уровнем и строкой не нужна.
}

module_init(my_module_init);
module_exit(my_module_exit); // Макрос. Ядро информируется о том, что в ядре теперь есть эти функции.
\end{lstlisting}

В модулях ядра есть только библиотеки ядра, стандартные библиотеки недоступны. 

\subsection{Пример Makefile}

\begin{lstlisting}
obj_m += module.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(pwd) modules
    
clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(pwd) clean
\end{lstlisting}

\section{Информация о процессах, доступная в ядре. Пример вывода информации о запущенных процессах, символ current (лаб. раб.)}

\begin{lstlisting}
    #include <linux/init_task.h>
#include <linux/module.h>
#include <linux/sched.h>
#include <linux/fs_struct.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Inspirate789");

static int __init mod_init(void)
{
    printk(KERN_INFO " + module is loaded.\n");
    struct task_struct *task = &init_task;
    do
    {
        printk(KERN_INFO " + %s (%d) (%d - state, %d - prio, flags - %d, policy - %d), parent %s (%d), d_name %s",
            task->comm, task->pid, task->__state, task->prio, task->flags, task->policy, task->parent->comm, task->parent->pid, task->fs->root.dentry->d_name.name);
    } while ((task = next_task(task)) != &init_task);

   // task = current;
    printk(KERN_INFO " + %s (%d) (%d - state, %d - prio, flags - %d, policy - %d), parent %s (%d), d_name %s",
        current->comm, current->pid, current->__state, current->prio, current->flags, current->policy, current->parent->comm, current->parent->pid, current->fs->root.dentry->d_name.name);
    return 0;
}

static void __exit mod_exit(void)
{
    printk(KERN_INFO " + %s - %d, parent %s - %d\n", current->comm,
           current->pid, current->parent->comm, current->parent->pid);
    printk(KERN_INFO " + module is unloaded.\n");
}

module_init(mod_init);
module_exit(mod_exit);
\end{lstlisting}

Дескрипторы процессов организованы в ядре в кольцевой список: начало - init\_task, переход на следующий дескриптор - next\_task().

insmod -- загрузить модуль ядра

lsmod -- посмотреть список модулей ядра

rmmod -- выгрузить загруженный модуль из ядра

Все эти действия доступны только с правами superuser

Вывести инф. из лога: dmesg

При этом надо использовать ссылку current (текущий процесс)

\textit{Всего 8 уровней протоколирования(уровней вывода сообщений)}

0 -- KERN\_EMERGE (опасность, упала система)

1 -- KERN\_ALERT (тревога, система скоро упадет)

2 -- KERN\_CRIT 

3 -- KERN\_ERR 

4 -- KERN\_WARNING 

5 -- KERN\_NOTICE 

6 -- KERN\_INFO 

7 -- KERN\_DEBUG 


\textit{Несмотря на то, что у user есть proc, в ядре информации все равно больше}

\section{Взаимодействие загружаемых модулей в ядре. Экспорт данных}

Для того, чтобы в модуле использовать данные из другого модуля, нужно иметь абсолютные адреса экспортируемых имён ядра (символов) и модулей, по которым происходит связывание имён в компилируемом модуле.

\textbf{Абсолютный адрес} - адрес в физической памяти. Цилюрик называет это абсолютными адресами в пространстве ядра.

Процессы оперируют виртуальными адресами (процессы имеют виртуальное адресное пространство), а ядро - физическими.

\section{Пример взаимодействия модулей (лаб. раб.)}
\textbf{kernel\_module.h}
\begin{lstlisting}
extern char *module_1_data;
extern char *module_1_proc(void);
extern char *module_1_noexport(void);
\end{lstlisting}

\textbf{module\_1.c}
\begin{lstlisting}
    #include <linux/init.h>
#include <linux/module.h>

// #include "kernel_module.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Inspirate789");

char *module_1_data = "ABCDE";

extern char *module_1_proc(void) { return module_1_data; }
static char *module_1_local(void) { return module_1_data; }
extern char *module_1_noexport(void) { return module_1_data; }

EXPORT_SYMBOL(module_1_data);
EXPORT_SYMBOL(module_1_proc);

static int __init module_1_init(void)
{
    printk("+ module_1 started.\n");
    printk("+ module_1 use local from module_1: %s\n", module_1_local());
    printk("+ module_1 use noexport from module_1: %s\n", module_1_noexport());
    return 0;
}

static void __exit module_1_exit(void) { printk("+ module module_1 unloaded.\n"); }

module_init(module_1_init);
module_exit(module_1_exit);
\end{lstlisting}

\textbf{module\_2.c}
\begin{lstlisting}
    #include <linux/init.h>
#include <linux/module.h>

#include "kernel_module.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Inspirate789");

static int __init module_2_init(void)
{
    printk("+ module module_2 started.\n");
    printk("+ data string exported from module_1: %s\n", module_1_data);
    printk("+ string returned module_1_proc(): %s\n", module_1_proc());

    //printk( "+ module_2 use local from module_1: %s\n", module_1_local());

    //printk( "+ module_2 use noexport from module_1: %s\n", module_1_noexport());

    return 0;
}

static void __exit module_2_exit(void)
{
    printk("+ module_2 unloaded.\n");
}

module_init(module_2_init);
module_exit(module_2_exit);
\end{lstlisting}

\textbf{module\_3.c}
\begin{lstlisting}
    #include <linux/init.h>
#include <linux/module.h>

#include "kernel_module.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Inspirate789");

static int __init module_2_init(void)
{
    printk("+ module_3 started.\n");
    printk("+ data string exported from module_1: %s\n", module_1_data);
    printk("+ string returned module_1_proc() is: %s\n", module_1_proc());

    return -1;
}
module_init(module_2_init);
\end{lstlisting}

\subsection{Ошибки}
extern сообщает компилятору, что следующие за ним типы и имена определены в другом месте. Внешние модули могут использовать только те имена, которые экспортируются. Локальное имя не подходит для связывания. EXPORT\_SYMBOL позволяет предоставить API для других модулей/кода. Модуль не загрузится, если он ожидает символ, а его нет в ядре.

Один модуль может использовать данные и функции, используемые в другом модуле. Модуль module\_2, использующий экспортируемое имя, связывается с этим именем по абсолютному (физическому) адресу (адресу в оперативной памяти). Модуль может использовать только экспортируемые имена. 

Если модуль вернет -1 на init (md3) --- ошибка инициализации модуля, он не будет загружен.

1. Пробуем загрузить cначала только module\_2:
\begin{lstlisting}
    $ sudo insmod module_2.ko
insmod: ERROR: could not insert module module_2.ko: Unknown symbol in module
\end{lstlisting}

В журнале:
\begin{lstlisting}
$ dmesg
[ 6987.204306] module_2: Unknown symbol module_1_data (err -2)
[ 6987.204337] module_2: Unknown symbol module_1_proc (err -2)
\end{lstlisting}

Ошибка загрузки.

2. Теперь в правильном порядке:

\begin{lstlisting}
    $ sudo insmod module_1.ko
$ sudo insmod module_2.ko
$ lsmod | head -1 && lsmod | grep module_
Module                  Size  Used by
module_2                16384    0
module_1                16384    1 module_2
\end{lstlisting}

На модуль module\_1 ссылается некоторые другие модули или объекты ядра: 1 — число ссылок на модуль (один модуль ссылается на другой).

3. Пытаемся выгрузить:
\begin{lstlisting}
    $ sudo rmmod module_1
rmmod: ERROR: Module module_1 is in use by: module_2
\end{lstlisting}
До тех пор, пока число ссылок на любой модуль в системе не станет равно 0, модуль не может быть выгружен.

\begin{lstlisting}
$ sudo rmmod module_2
$ sudo rmmod module_1
$ lsmod | head -1 && lsmod | grep module_
Module                  Size  Used by
\end{lstlisting}

4. Используем module\_1\_local
\begin{lstlisting}
	static char *module_1_local(void) { return module_1_data; }
\end{lstlisting}

Функция не объявлена как extern, не указано EXPORT\_SYMBOL, поэтому ошибка компиляции. implicit declaration of function module\_1\_local.

5. Используем module\_1\_noexport
\begin{lstlisting}
	extern char *module_1_noexport(void) { return module_1_data; }
\end{lstlisting}

Не указан EXPORT\_SYMBOL для функции module\_1\_noexport. Ошибка сборки ERROR: modpost: "md1\_noexport" [<путь\_к\_файлу>/md2.ko] undefined!.

\section{Функция printk() – назначение и особенности}
Функция printk() определена в ядре Linux и доступна модулям. Функция аналогична библиотечной функции printf(). Загружаемый модуль ядра не может вызывать обычные библиотечные функции, поэтому ядро предоставляет модулю функцию printk(). Функция пишет сообщения в системный лог.

\section{Регистрация функций работы с файлами. Пример заполненной структуры}

Существует 2 типа файлов --- файл, к-ый лежит на диске и открытый файл. Открытый файл -- файл, который открывает процесс

\textbf{Кратко}

struct file описыает открытый файл. В ядре имеется сист. табл. открытых файлов. Каждый процесс имеет собственную таблицу открытых файлов, дескрипторы которой ссылаются на дескрипторы в таблице открытых файлов.

\textbf{Подробно}

Если файл просто лежит на диске, то через дерево каталогов можно увидеть это. 

Увидеть можно только подмонтированную ФС.

А есть открытые файлы --- файлы, с которыми работают процессы. Только процесс может открыть файл.

struct file описывает открытые файлы, которые нужны процессу для выполнения действий.

В системе сушествует \textbf{одна} табл. открытых файлов.

struct file -- дескриптор открытого файла.

Открыть файл может только процесс. Если файл открывается потоком, то он в итоге все равно открывается процессом (как ресурс). Ресурсами владеет процесс.


\subsubsection{Таблицы открытых векторов}

Помимо таблицы открытых файлов процесса (есть у каждого процесса), в системе есть одна таблица на все открытые файлы.

Причем в этой таблице на один и тот же файл (с одним и тем же inode) мб создано большое кол-во дескрипторов открытых файлов, т.к. один и тот же файл мб открыт много раз. 

Каждое открытие файла с одним и тем же inode приведет к созданию дескриптора открытого файла.

При открытии файла его дескриптор добавляется:
\begin{enumerate}
    \item в таблицу открытых файлов процесса (struct file\_struct)
    \item в системную таблицу открытых файлов
\end{enumerate}

Каждый дескриптор struct file имеет поле f\_pos, это приводит к гонкам. При работе с файлами это надо учитывать.

Один и тот же файл, открытый много раз без соотв. способов взаимоискл. будет атакован, что приведет к потере данных.

Гоники при разделении файлов -- один и тот же файл мб открыт разными процессами.

\subsubsection{Определение struct file}
\begin{lstlisting}
    struct file {
	struct path		f_path;
	struct inode		*f_inode;	/* cached value */
	const struct file_operations	*f_op;
        ...
	atomic_long_t		f_count;// кол-во жестких ссылок
	unsigned int 		f_flags;
	fmode_t			f_mode;
	struct mutex		f_pos_lock;
	loff_t			f_pos;
	...
	struct address_space	*f_mapping;
	...
};
\end{lstlisting}
Как осуществляется отображение файла на физ. страницы?

дескриптор открытого файла имеет указатель на inode (файл на диске).

\subsection{Регистрация функций для работы с файлами}
Разработчики драйверов должны регистрировать свои ф-ции read/write

Зачем в UNIX/Linux все файл?

Для того, чтобы все действия свести к однотипным операциям (read/write) и не размножать эти действия, а именно свести к небольшому набору операций.

Для регистрации своих функций read/write в драйверах используется struct file\_operations.

С некоторой версии ядра 5.16+ (примерно) появилась struct proc\_ops. В загружаемых модулях ядра можно использовать условную компиляцию:

\begin{lstlisting}
    #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
#define HAVE_PROC_OPS
#endif

#ifdef HAVE_PROC_OPS
static struct proc_ops fops = {
    .proc_read = fortune_read,
    .proc_write = fortune_write,
    .proc_open = fortune_open,
    .proc_release = fortune_release,
};
#else
static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read = fortune_read,
    .write = fortune_write,
    .open = fortune_open,
    .release = fortune_release,
};
#endif
\end{lstlisting}

proc\_open и open имеют одни и те же формальные параметры (указатели на struct inode и на struct file)

С остальными функциями аналогично. struct proc\_ops сделана, чтобы не вешаться на функции struct file\_operations, которые используются драйверами. Функции struct file\_operations настолько важны для работы системы, что их решили освободить от работы с ф.с. proc 

\section{Передача данных из пространства ядра в пространство пользователя и из пространства пользователя в пространство ядра. Примеры из лабораторный работ}
\textbf{ЗДЕСЬ ССЫЛКА НА 14}