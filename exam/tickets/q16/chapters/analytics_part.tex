\chapter{Билет №16}

\section*{Открытые файлы: системный вызов open(): int open(const char* pathname, int flags); int open(const char* pathname, int flags, mode\_t mode); пояснить смысл параметров. Основные флаги. Флаг CREATE. Реализация системного вызова open() в системе – действия в ядре: \\SYSCALL\_DEFINE3(open,…) -> ksys\_open(filename, flags, mode) -> do\_sys\_open() -> do\_sys\_openat2() … найти наименьший файловый дескриптор... Действия, если флаг O\_CREATE установлен?}

\section{Файл}
Файл --- важнейшее понятие в файловой подсистеме. Файл --- информация, хранимая во вторичной памяти или во вспомогательном ЗУ с целью ее сохранения после завершения отдельного задания или преодоления ограничений, связанных в объемом основного ЗУ.

Файл --- поименованная совокупность данных, хранимая во вторичной памяти (возможно даже целая). Файл --- каждая индивидуально идентифицированная единица информации.

Существует 2 ипостаси файла:
\begin{enumerate}
	\item файл, который лежит на диске;
	\item открытый файл (с которым работает процесс).
\end{enumerate}

Открытый файл -- файл, который открывает процесс.

Для такого файла создается дескриптор файла в таблице открытых файлов процесса (struct files\_struct).

Но этого мало.

Необходимо создать дескриптор открытого файла в сист. табл. открытых файлов (struct file)

\section{Файловая подсистема}
Файл != место на диске. В мире современной вычислительной техники файлы имеют настолько большие размеры, что не могут храниться в непрерывном физическом адресном пространстве, они хранятся вразброс (несвязанное распределение).

Файл может занимать разные блоки/сектора/дорожки на диске аналогично тому, как память поделена на страницы. В любой фрейм может быть загружена новая страница, как и файл. 

Также, важно понимать адресацию. Соответственно, система должна обеспечить адресацию каждого такого участка.

Любая ОС без ФС не может быть полноценной. Задача ФС --- обеспечивать сохранение данных и доступ к сохраненным данным (обеспечивать работу с файлами).

Чтобы обеспечить хранение файла и последующий доступ к нему, файл должен быть изолирован, то есть занимать некоторое адресное пространство, и это адресное пространство должно быть защищено. Доступ обеспечивается по тому, как файл идентифицируется в системе (доступ осуществляется по его имени).

ФС --- порядок, определяющий способ организации хранения, именования и доступа к данным на вторичных носителях информации.

\begin{quote}
	File management (управление файлами) --- программные процессы, связанные с общим управлением файлами, то есть с размещением во вторичной памяти, контролем доступа к файлам, записью резервных копий, ведением справочников (directory).
	
	Основные функции управления файлами обычно возлагаются на ОС, а дополнительные --- на системы управления файлами.
	
	Доступ к файлам: open, read, write, rename, delete, remove.
	
	Разработка UNIX началась с ФС. Без ФС невозможно создание приложений, работающих в режиме пользователя (сложно разделить user mode и kernel mode).
	
	Файловая подсистема взаимодействует практически со всеми модулями ОС, предоставляя пользователю возможность долговременного хранения данных, а также ОС возможность работать с объектами ядра.
\end{quote}

\subsection{struct file}

Существует 2 типа файлов --- файл, к-ый лежит на диске и открытый файл. Открытый файл -- файл, который открывает процесс

\textbf{Кратко}

struct file описывает открытый файл.

\textbf{Подробно}

Если файл просто лежит на диске, то через дерево каталогов можно увидеть это. 

Увидеть можно только подмонтированную ФС.

А есть открытые файлы --- файлы, с которыми работают процессы.

Открыть файл может только процесс. Если файл открывается потоком, то он в итоге все равно открывается процессом (как ресурс). Ресурсами владеет процесс.


\subsubsection{Таблицы открытых файлов}

Помимо таблицы открытых файлов процесса (есть у каждого процесса), в системе есть одна таблица на все открытые файлы (на которую ссылаются таблицы процессов).

Причем в этой таблице на один и тот же файл (с одним и тем же inode) мб создано большое кол-во дескрипторов открытых файлов, т.к. один и тот же файл мб открыт много раз. 

Каждое открытие файла с одним и тем же inode приведет к созданию дескриптора открытого файла.

При открытии файла его дескриптор добавляется:
\begin{enumerate}
    \item в таблицу открытых файлов процесса (struct file\_struct)
    \item в системную таблицу открытых файлов
\end{enumerate}

Каждый дескриптор struct file имеет поле f\_pos. При работе с файлами это надо учитывать.

Один и тот же файл, открытый много раз без соотв. способов взаимоискл. будет атакован, что приведет к потере данных.

\sout{Гонки при разделении файлов -- один и тот же файл мб открыт разными процессами.}

\subsubsection{Определение struct file}
\begin{lstlisting}
    struct file {
  struct path    f_path;
  struct inode    *f_inode;  /* cached value */
  const struct file_operations  *f_op;
        ...
  atomic_long_t    f_count;// кол-во жестких ссылок
  unsigned int     f_flags;
  fmode_t      f_mode;
  struct mutex    f_pos_lock;
  loff_t      f_pos;
  ...
  struct address_space  *f_mapping;
  ...
};
\end{lstlisting}
Как осуществляется отображение файла на физ. страницы? - дескриптор открытого файла имеет указатель на inode (файл на диске).

\textbf{Связь между struct file и struct file operations}

Файл должен быть открыт. Соответственно для открытого файла должен быть создан дескриптор. В этом дескрипторе имеется указатель на struct file\_operations. Это либо стандартные (установленные по умолчанию) операции на файлах для конкретной файловой системы, либо зарегистрированные разработчиком (собственные функции работы с файлами собственной файловой системы).

\begin{lstlisting}
	struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	...
	int (*open) (struct inode *, struct file *);
	...
	int (*release) (struct inode *, struct file *);
	...
} __randomize_layout;
\end{lstlisting}

\section{Системный вызов open()}
Системный вызов open() открывает файл, определённый $pathname$.

\textbf{Возвращаемое значение}

open() возвращает файловый дескриптор~---~небольшое неотрицательное целое число, которое является ссылкой на запись в системной таблице открытых файлов и индексом записи в таблице дескрипторов открытых файлов процесса. Этот дескриптор используется далее в системных вызовах read(), write(), lseek(), fcntl() и т.д. для ссылки на открытый файл. В случае успешного вызова будет возвращён наименьший файловый дескриптор, не связанный с открытым процессом файлом.

В случае ошибки возвращается -1 и устанавливается значение errno.

\textbf{Параметры}

$pathname$~---~имя файла в файловой системе. $flags$~---~режим открытия файла~---~один или несколько флагов открытия, объединенных оператором побитового ИЛИ. 

\begin{lstlisting}
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open (const char *pathname, int flags);
int open (const char *pathname, int flags, mode_t mode);
\end{lstlisting}

2 варианта open():
\begin{enumerate}
    \item Если ф-ция open предназначени для работы с существующим файлом, то это ф-ция вызывается с 2 параметрами.
    \item Если пользователь желает создать файл и использует флаг O\_CREATE или O\_TMPFILE, то он должен указать 3-й пар-р --- mode; Если эти флаги не указаны, то 3-й параметр игнорируется.
\end{enumerate}

Так, можно открыть существующий файл, а можно открыть новый (создать) файл. Создать файл --- создать inode.


\section{Основные флаги. Флаг CREATE}

\begin{quote}

O\_CREAT

(если файл не существует, то он будет создан. Владелец (идентификатор пользователя) файла устанавливается в значение эффективного идентификатора пользователя процесса. Группа (идентификатор группы) устанавливается либо в значение эффективного идентификатора группы процесса, либо в значение идентификатора группы родительского каталога (зависит от типа файловой системы, параметров подсоединения (mount) и режима родительского каталога, см. например, параметры подсоединения bsdgroups и sysvgroups файловой системы ext2, как описано в руководстве mount(8)).);

O\_EXCL

(Если он используется совместно с O\_CREAT, то при наличии уже созданного файла вызов open завершится с ошибкой. В этом состоянии, при существующей символьной ссылке не обращается внимание, на что она указывает.);

O\_EXCL

(Оно не работает в файловых системах NFS, а в программах, использующих этот флаг для блокировки, возникнет "race condition". Решение для атомарной блокировки файла: создать файл с уникальным именем в той же самой файловой системе (это имя может содержать, например, имя машины и идентификатор процесса), используя link(2), чтобы создать ссылку на файл блокировки. Если link() возвращает значение 0, значит, блокировка была успешной. В противном случае используйте stat(2), чтобы убедиться, что количество ссылок на уникальный файл возросло до двух. Это также означает, что блокировка была успешной);

O\_APPEND

(Файл открывается в режиме добавления. Перед каждой операцией write файловый указатель будет устанавливаться в конце файла, как если бы использовался lseek); O\_APPEND (может привести к повреждению файлов в системе NFS, если несколько процессов одновременно добавляют данные в один файл. Это происходит из-за того, что NFS не поддерживает добавление в файл данных, поэтому ядро на машине-клиенте должно эмулировать эту поддержку);

\end{quote}

\textbf{O\_RDONLY} - открыть файл только на чтение

\textbf{O\_WRONLY} - открыть файл только на запись

\textbf{O\_RDWR}- открыть файл для чтения и записи

\textbf{O\_PATH} - получить лишь файловый дескриптор (сам файл не будет открыт). \textit{ Будет возвращен дескриптор struct file(он уже  существует, мы его не создаем), при этом сам файл не открывается. Если флаг не установлен, то будет организован цикл по всем эл-там пути и вызвана ф-ция do\_open, которая открывает файл, т.е. создает дескриптор (инициализирует поля struct file).}


\textbf{O\_TMPFILE} - создать неименованный временный обычный файл. Предполагает создание временного файла. Если он установлен, будет вызвана ф-ция do\_tmpfile.

\textbf{O\_APPEND} - установить смещение f\_pos на конец файла.


\textbf{O\_CREAT} - если файл не существует, то он будет создан, id владельца и группы файла устанавливаются действующим id пользователя и группы процесса.

Младшие 12 бит значения режима доступа к файлу устанавливается равными значению аргумента mode, модифицированному следующим образом:

- Биты, соответствующие единичным битам маски режима создания файлов текущего процесса устанавливаются в 0

- Бит навязчивости устанавливается равным в 0

Если установлен флаг O\_CREAT и указано несуществующее имя файла (система это контролирует), то д.б. создан inode.

\textbf{O\_TRUNC} - если файл уже существует, он является обычным файлом и заданный режим позволяет записывать в этот файл, то его размер будет установлен в 0 (вся информация будет удалена). Режим доступа и владелец не меняются.

\textbf{O\_EXCL }- если установлен O\_EXCL и O\_CREAT и указано имя существующего файла (файл уже существует), то open вернёт ошибку. Библиотечная функция fopen этого не делает.

\textbf{O\_LARGEFILE} - позволяет открывать файлы, размер которых не может
быть представлен типом off\_t (long). Для установки должен быть указан макрос 
\_LARGEFILE64\_SOURCE.

\textbf{O\_CLOEXEC} - устанавливает флаг \textit{close-on-exec} для нового файлового дескриптора, указание этого флага позволяет программе избегать дополнительных операций fcntl F\_SETFD для установки флага FD\_CLOEXEC.


\textbf{O\_EXEC} - открыть только для выполнения (результат не определен при открытии директории).

Режим (права доступа): 

Если мы создаем новый файл, то мы должны указать права доступа к файлу. 

Для режима предусмотрены константы (для пользователя/группы):

-  SR\_IRWXU / SR\_IRWXG - права доступа на чтение, запись и исполнение

- SR\_IRUSR / SR\_IRGRP - права на чтение

- SR\_IWUSR / SR\_IWGRP - права на запись

- SR\_IXUSR / SR\_IXGRP - права на исполнение

\section{Реализация системного вызова open() в системе – действия в ядре}
open(), как и любой системный вызов переводит систему в режим ядра.

Сначала ищется свободный дескриптор в struct files\_struct (в массиве дескрипторов открытых файлов процесса), потом при опр. усл-ях создается дескриптор открытого файла в системной таблице открытых файлов, затем при опрю усл-ях создается inode.

\section{SYSCALL\_DEFINE3(open,…)}
В режиме ядра есть syscall table.

В системе есть 6 макросов -- syestem call macro. У всех 1 параметр -- имя сист. вызова.

С open() работает третий:

SYSCALL\_DEFINE3(open, const char \_\_user *filename, int flags, mode\_t mode);

\begin{lstlisting}
    SYSCALL_DEFINE3(open, const char __user *filename, int flags, mode_t mode)
    {
    if (force_o_largefile())
        flags |= O_LARGEFILE;
    return do_sys_open(AT_FDCWD, filename, flags, mode)
    }
\end{lstlisting}

filename -- имя файла, которое передается из пространства пользователя в пр-во ядра. Это нельзя сделать напрямую. Впоследствии будет вызвана ф-ция str\_copy\_from\_user() для передачи имени файла в ядро (это делается последовательно в результате ряда вызовов функций).

В макросе выполняется проверка того, какая у нас система: если 64-разр., то в ней есть большие файлы (largefile), и флаг O\_LARGEFILE добавляется к флагам, к-ые были установлены.

Основная задача макроса -- вызов ф-ции ядра do\_sys\_open()

\section{do\_sys\_open()}
\begin{lstlisting}
    long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
  struct open_flags op;
  int fd = build_open_flags(flags, mode, &op);
  struct filename *tmp;

  if (fd)
    return fd;

  tmp = getname(filename);
  if (IS_ERR(tmp))
    return PTR_ERR(tmp);

  fd = get_unused_fd_flags(flags);//обертка __alloc_fd()
  if (fd >= 0) {
    struct file *f = do_filp_open(dfd, tmp, &op);
    if (IS_ERR(f)) {
      put_unused_fd(fd);
      fd = PTR_ERR(f);
    } else {
      fsnotify_open(f);
      fd_install(fd, f);
    }
  }
  putname(tmp);
  return fd;
}
\end{lstlisting}

\section{do\_filp\_open()}
Основную работу по открытию файла и связанные с этим действия выполняет ф-ция do\_filp\_open().

\textit{struct filename и struct open\_flags --- эти структуры инициализированны в результате работы функций, которые были вызваны ранее}

\begin{lstlisting}
    struct file *do_filp_open(int dfd, struct filename *pathname,
    const struct open_flags *op)
{
  struct nameidata nd; // внутренняя служебная структура
  int flags = op->lookup_flags;
  struct file *filp;

  set_nameidata(&nd, dfd, pathname);
  filp = path_openat(&nd, op, flags | LOOKUP_RCU);
  if (unlikely(filp == ERR_PTR(-ECHILD)))
    filp = path_openat(&nd, op, flags);
  if (unlikely(filp == ERR_PTR(-ESTALE)))
    filp = path_openat(&nd, op, flags | LOOKUP_REVAL);
  restore_nameidata();
  return filp;
}
\end{lstlisting}

\section{build\_open\_flags()}
Задачи ф-ции build\_open\_flags() -- инициализация полей struct open\_flags на основе флагов, указанных пользователем

В этой функции анализируются все флаги.

\section{get\_unused\_fd\_flags()}
Можно предположить, что ф-ция get\_unused\_fd\_flags должна найти неиспользуемый файловый дескриптор в таблице дескрипторов открытых файлов для того, чтобы выделить его, и open() мог его вернуть.

\section{alloc\_fd()}
При этом ф-ция \_\_alloc\_fd() использует spin-lock'и, т.к. эти действия могут выполнять несколько процессов/потоков.

\section{getname()}
Ф-ция getname() вызывает get\_name\_flags(), которая копирует имя файла из пр-ва пользователя в пр-во ядра. При этом используется ф-ция str\_copy\_from\_user().

Для любого процесса файловые дескрипторы 0, 1, 2 (stdin, stdout, stderr) занимаются автоматически, но для этих дескрипторов необходимо проделать все действия так же, как при вызове open() в приложении.


\section{set\_nameidata()}
Ф-ция set\_nameidata инициализирует поля struct nameidata.

\section{path\_openat()}
Функция path\_openat возвращает инициализированный дескриптор открытого файла (struct file)

\underline{1-й вызов}

'Быстрый проход': игнорируются некоторые проверки. Это проход по всем флагам и выполнение соотв. анализа.

\underline{2-й вызов}

'Обычный'(если быстрый проход вернул ошибку).

\underline{3-й вызов}

Для файлов NFS (network filesystem).

В NFS не работает флаг O\_APPEND, возникают гонки. O\_APPEND позволяет дописывать данные в конец файла без потери данных в нем.

Гонки при разделении файлов --- один и тот же файл мб открыт разными процессами.

\begin{lstlisting}
    static struct file *path_openat(struct nameidata *nd,
      const struct open_flags *op, unsigned flags)
{
  const char *s;
  struct file *file;
  int opened = 0;
  int error;

  file = get_empty_filp();
  if (IS_ERR(file))
    return file;

  file->f_flags = op->open_flag;

  if (unlikely(file->f_flags & __O_TMPFILE)) {
    error = do_tmpfile(nd, flags, op, file, &opened);
    goto out2;
  }

  if (unlikely(file->f_flags & O_PATH)) {
    error = do_o_path(nd, flags, file);
    if (!error)
      opened |= FILE_OPENED;
    goto out2;
  }

  s = path_init(nd, flags);
  if (IS_ERR(s)) {
    put_filp(file);
    return ERR_CAST(s);
  }
  while (!(error = link_path_walk(s, nd)) &&
    (error = do_last(nd, file, op, &opened)) > 0) {
    nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
    s = trailing_symlink(nd);
    if (IS_ERR(s)) {
      error = PTR_ERR(s);
      break;
    }
  }
  terminate_walk(nd);
out2:
  if (!(opened & FILE_OPENED)) {
    BUG_ON(!error);
    put_filp(file);
  }
  if (unlikely(error)) {
    if (error == -EOPENSTALE) {
      if (flags & LOOKUP_RCU)
        error = -ECHILD;
      else
        error = -ESTALE;
    }
    file = ERR_PTR(error);
  }
  return file;
}

\end{lstlisting}

\textit{
Функции ядра специфицированы, но не стандартизованы (в отличие от сист. вызовов, которые стандартизованы POSIX). Поэтому функции и структуры ядра переписываются.}

\textit{
Для того, чтобы определить, существует ли файл, нужно пройти по цепочке dentry (задействуется struct dentry).}






