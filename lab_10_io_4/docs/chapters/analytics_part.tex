\chapter{Программы}

\section{Первая программа}

\img{80mm}{1.png}{Связь структур}

\subsubsection{Однопоточная реализация}
\begin{lstlisting}
#include <stdio.h>
#include <fcntl.h>

int main() {
  int fd = open("alphabet.txt", O_RDONLY);

  FILE *fs1 = fdopen(fd, "r");
  char buff1[20];
  setvbuf(fs1, buff1, _IOFBF, 20);

  FILE *fs2 = fdopen(fd,"r");
  char buff2[20];
  setvbuf(fs2, buff2, _IOFBF, 20);

  int flag1 = 1, flag2 = 2;
  while (flag1 == 1 || flag2 == 1) {
    char c;
    flag1 = fscanf(fs1, "%c", &c);
    if (flag1 == 1)
      fprintf(stdout, "%c", c);
    flag2 = fscanf(fs2, "%c", &c);

    if (flag2 == 1)
      fprintf(stdout, "%c", c);
  }
  return 0;
}
\end{lstlisting}
\img{20mm}{1s.png}{Вывод программы}

С помощью системного вызова open() создается дескриптор открытого
файла. Системный вызов open() возвращает индекс в массиве fd\_array структуры files\_struct. Библиотечная функция fdopen() возвращает указатели на struct FILE (fs1 и fs2), которые ссылаются на дескриптор, созданный
системным вызовом open(). Далее создаются буферы buff1 и buff2 размером 20
байт. Для дескрипторов fs1 и fs2 функцией setvbuf() задаются соответствующие
буферы и тип буферизации \_IOFBF.

Далее fscanf() выполняется в цикле поочерёдно для fs1 и fs2. При
вызове fscanf() для fs1 в буфер buff1 считаются первые 20 символов. Значение f\_pos в структуре struct file открытого увеличится на 20. В переменную c
записывается символ 'a' и выводится с помощью fprintf(). При вызове fscanf() для fs2 в буфер buff2 считываются оставшиеся 6 символов.

В цикле символы из buff1 и buff2 будут поочередно выводиться до тех
пор, пока символы в одном из буферов не закончатся. Тогда на экран будут 
последовательно выведены оставшиеся символы из другого буфера.

\subsubsection{Многопоточная реализация}
\begin{lstlisting}
#include <stdio.h>
#include <fcntl.h>
#include <pthread.h>

void *task(void *fd) {
  int flag = 1;
  char c;

  FILE *fs = fdopen((int)fd,"r");
  char buff[20];
  setvbuf(fs, buff, _IOFBF, 20);

  while (flag == 1) {
    flag = fscanf(fs,"%c",&c);
    if (flag == 1)
      fprintf(stdout,"%c",c);
  }
}

int main(){
  int fd = open("alphabet.txt", O_RDONLY);

  pthread_t thids[2];
  pthread_create(thids,NULL,task,(void *)fd);
  pthread_create(thids+1,NULL,task,(void *)fd);

  pthread_join(thids[0],NULL);
  pthread_join(thids[1],NULL);
  return 0;
}
\end{lstlisting}
\img{20mm}{1m.png}{Вывод программы}

В многопоточной реализации в цикле символы из
buff1 и buff2 будут выводиться параллельно. Обе структуры \_IO\_FILE
имеют одинаковый файловый дескриптор, поэтому в файл будет записан весь алфавит,
но порядок символов не может быть гарантировано определён.

\section{Вторая программа}

\img{90mm}{2.png}{Связь структур}

\subsubsection{Однопоточная реализация}
\begin{lstlisting}
#include <fcntl.h>
#include <unistd.h>

int main() {
  char c;
  int fd1 = open("alphabet.txt", O_RDONLY);
  int fd2 = open("alphabet.txt", O_RDONLY);
  int flag1 = 1,flag2 = 1;
  while(flag1 && flag2) {
    if ((flag1 = read(fd1,&c,1)))
      write(1,&c,1);
    if ((flag2 = read(fd2,&c,1)))
      write(1,&c,1);
  }
  return 0;
}
\end{lstlisting}
\img{20mm}{2s.png}{Вывод программы}

Один и тот же файл открывается дважды, следовательно создается
две структуры struct file, в которых f\_inode указывает на один и тот же
struct inode. У каждого файлового дескриптора своя позиция (f\_pos), поэтому
при чтении из fd1 и fd2 файл прочитывается от начала до конца. Используя
каждый дескриптор, читаем по одному символу и выводим его, в результате
получаем, что каждый символ выводится дважды.

\subsubsection{Многопоточная реализация}
\begin{lstlisting}
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>

void *task() {
  int fd = open("alphabet.txt",O_RDONLY);
  int flag = 1;
  char c;

  while (flag) {
    if ((flag=read(fd,&c,1)))
      write(1,&c,1);
  }
}

int main(){
  pthread_t thids[2];
  pthread_create(thids,NULL,task,NULL);
  pthread_create(thids+1,NULL,task,NULL);

  pthread_join(thids[0],NULL);
  pthread_join(thids[1],NULL);
  return 0;
}
\end{lstlisting}
\img{20mm}{2m.png}{Вывод программы}

Каждый поток читает и пишет в stdout. Так как оба потока пишут
одновременно, алфавит перемешивается. Из-за того, что запись происходит 
асинхронно, гарантировано предсказать, как именно будет выглядеть вывод, невозможно.

\section{Третья программа, версия с использованием stdio.h}

\img{90mm}{3.png}{Связь структур}

\subsubsection{Однопоточная реализация}
\begin{lstlisting}
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>

#define PRINT_STAT(path, action) \
  do { \
    stat(path, &statbuf); \
    fprintf(stdout, action ": inode num = %ld, size = %ld, blksize = %ld\n", \
    statbuf.st_ino, statbuf.st_size, \
    statbuf.st_blksize); \
  } while (0)

int main() {
  struct stat statbuf;
  FILE *file1 = fopen("output.txt", "w");
  PRINT_STAT("output.txt", "fopen file1");
  FILE *file2 = fopen("output.txt", "w");
  PRINT_STAT("output.txt", "fopen file2");

  for (char ch='a'; ch<='z'; ch++) {
    if (ch % 2)
      fprintf(file1,"%c",ch);
    else
      fprintf(file2,"%c",ch);
    PRINT_STAT("output.txt", "fprintf");
  }
  
  fclose(file1);
  PRINT_STAT("output.txt", "fclose file1");
  fclose(file2);
  PRINT_STAT("output.txt", "fclose file2");
  return 0;
}
\end{lstlisting}
\img{120mm}{3s.png}{Вывод программы}

Файл открывается дважды с помощью fopen. Содержимое записывается
из буфера в файл в следующих случаях:
\begin{itemize}
  \item буфер уже заполнен и происходит попытка очередной записи в буфер;
  \item вызов fflush();
  \item вызов функций close(), fclose().
\end{itemize}

В данном случае запись в файл происходит в результате вызова функции
fclose(). При вызове fclose() для fs1 буфер для fs1 записывается в файл. При
вызове fclose() для fs2, все содержимое файла очищается, а в файл записыва-
ется содержимое буфера для fs2. В итоге произошла потеря данных, в файле
окажется только содержимое буфера для fs2.

\subsubsection{Многопоточная реализация}
\begin{lstlisting}
#include <stdio.h>
#include <fcntl.h>
#include <pthread.h>

void *task(void *payload) {
  int n = (int)payload;
  FILE *file = fopen("output.txt", "w");
  for (char ch = 'a'; ch <= 'z'; ch++) {
    if (ch % 2 == n)
      fprintf(file,"thread_ind = %d: char = %c\n", n, ch);
  }
  fclose(file);
  return 0;
}

int main() {
  pthread_t thids[2];
  pthread_create(thids, NULL, task, (void *)0);
  pthread_create(thids+1, NULL, task, (void *)1);
  pthread_join(thids[0],NULL);
  pthread_join(thids[1],NULL);
  return 0;
}
\end{lstlisting}
\img{90mm}{3m.png}{Вывод программы}

В многопоточной программе работа с файлом производится аналогично
однопоточной программе. Если вызывать fclose() в дополнительном потоке, то
порядок вывода символов не может быть гарантировано определён, так как нельзя предсказать заранее, какой поток последним вызовет fclose().

\section{Третья программа, версия с системными вызовами}

\img{170mm}{4.png}{Связь структур}

\subsubsection{Однопоточная реализация}
\begin{lstlisting}
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <stdio.h>

#define PRINT_STAT(path, prefix) \
  do { \
    stat(path, &statbuf); \
    fprintf(stdout, prefix ": inode num = %ld, size = %ld, blksize = %ld\n", \
    statbuf.st_ino, statbuf.st_size, \
    statbuf.st_blksize); \
  } while (0)

int main() {
  struct stat statbuf;
  int file1 = open("output.txt", O_RDWR);
  PRINT_STAT("output.txt", "open file1");
  int file2 = open("output.txt", O_RDWR);
  PRINT_STAT("output.txt", "open file2");

  for (char ch = 'a'; ch <= 'z'; ch++) {
    if (ch % 2)
      write(file1, &ch, 1);
    else
      write(file2, &ch, 1);
    PRINT_STAT("output.txt", "write");
  }

  close(file1);
  PRINT_STAT("output.txt", "close file1");
  close(file2);
  PRINT_STAT("output.txt", "close file2");
  return 0;
}
\end{lstlisting}
\img{120mm}{4s.png}{Вывод программы}

В программе файл дважды открывается на запись функцией open(). В системной 
таблице открытых файлов создаётся два дескриптора struct file, каждый из которых 
имеет собственный указатель f\_pos, но оба ссылаются на один
и тот же inode. С помощью системного вызова write() выполняется небуферизованный 
вывод. При 
изменении порядка вызова функций close() вывод программы не 
изменяется, так как вывод не буферизуется.

\img{130mm}{4s-o.png}{Вывод программы с использованием флага O\_APPEND}

Чтобы вывести алфавит полностью, можно
использовать системный вызов open() с флагом O\_APPEND. В таком случае 
будет происходить дозапись всех символов.

\subsubsection{Многопоточная реализация}
\begin{lstlisting}
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>

#define PRINT_STAT(path, prefix) \
  do { \
    stat(path, &statbuf); \
    fprintf(stdout, prefix ": inode num = %ld, size = %ld, blksize = %ld\n", \
    statbuf.st_ino, statbuf.st_size, \
    statbuf.st_blksize); \
  } while (0)

void *task(void *payload){
  int n = (int)payload;
  int file = open("output.txt", O_WRONLY);
  struct stat statbuf;

  for (char ch = 'a'; ch <= 'z'; ch++)
  if (ch % 2 == n) {
    write(file, &ch, 1);
    PRINT_STAT("output.txt", "write");
  }
  close(file);
  return 0;
}

int main() {
  pthread_t thids[2];
  pthread_create(thids,NULL,task,(void *)0);
  pthread_create(thids+1,NULL,task,(void *)1);
  pthread_join(thids[0],NULL);
  pthread_join(thids[1],NULL);
  return 0;
}
\end{lstlisting}
\img{120mm}{4m.png}{Вывод программы}

Поведение данной программы подобно поведению
многопоточной программы с использованием вызовов из stdio.

\img{130mm}{4m-o.png}{Вывод программы с использованием флага O\_APPEND}

В многопоточной реализации с использованием флага O\_APPEND
в файл будет записан весь алфавит, однако порядок символов не определён из-за
параллельного выполнения потоков.

\chapter{Структуры ядра}

\section{\_IO\_FILE}

\begin{lstlisting}
struct _IO_FILE {
  int _flags;
#define _IO_file_flags _flags
  char* _IO_read_ptr;	/* Current read pointer */
  char* _IO_read_end;	/* End of get area. */
  char* _IO_read_base;	/* Start of putback+get area. */
  char* _IO_write_base;	/* Start of put area. */
  char* _IO_write_ptr;	/* Current put pointer. */
  char* _IO_write_end;	/* End of put area. */
  char* _IO_buf_base;	/* Start of reserve area. */
  char* _IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  /*  char* _save_gptr;  char* _save_egptr; */
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
\end{lstlisting}

\section{files\_struct}

\begin{lstlisting}
	/*
 * Open file table structure
 */
struct files_struct {
  /*
   * read mostly part
   */
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable __rcu *fdt;
	struct fdtable fdtab;
  /*
   * written part on a separate cache line in SMP
   */
	spinlock_t file_lock ____cacheline_aligned_in_smp;
	unsigned int next_fd;
	unsigned long close_on_exec_init[1];
	unsigned long open_fds_init[1];
	unsigned long full_fds_bits_init[1];
	struct file __rcu * fd_array[NR_OPEN_DEFAULT];
};
\end{lstlisting}

\section{fdtable}

\begin{lstlisting}
struct fdtable {
	unsigned int max_fds;
	struct file __rcu **fd;      /* current fd array */
	unsigned long *close_on_exec;
	unsigned long *open_fds;
	unsigned long *full_fds_bits;
	struct rcu_head rcu;
};
\end{lstlisting}

\section{file}

\begin{lstlisting}
struct file {
	union {
		struct llist_node	f_llist;
		struct rcu_head 	f_rcuhead;
		unsigned int 		f_iocb_flags;
	};
	struct path		f_path;
	struct inode		*f_inode;	/* cached value */
	const struct file_operations	*f_op;
	/*
	 * Protects f_ep, f_flags.
	 * Must not be taken from IRQ context.
	 */
	spinlock_t		f_lock;
	atomic_long_t		f_count;
	unsigned int 		f_flags;
	fmode_t			f_mode;
	struct mutex		f_pos_lock;
	loff_t			f_pos;
	struct fown_struct	f_owner;
	const struct cred	*f_cred;
	struct file_ra_state	f_ra;
	u64			f_version;
#ifdef CONFIG_SECURITY
	void			*f_security;
#endif
	/* needed for tty driver, and maybe others */
	void			*private_data;
#ifdef CONFIG_EPOLL
	/* Used by fs/eventpoll.c to link all the hooks to this file */
	struct hlist_head	*f_ep;
#endif /* #ifdef CONFIG_EPOLL */
	struct address_space	*f_mapping;
	errseq_t		f_wb_err;
	errseq_t		f_sb_err; /* for syncfs */
} __randomize_layout
  __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
\end{lstlisting}

\section{inode}

\begin{lstlisting}
struct inode {
	umode_t			i_mode;
	unsigned short		i_opflags;
	kuid_t			i_uid;
	kgid_t			i_gid;
	unsigned int		i_flags;

#ifdef CONFIG_FS_POSIX_ACL
	struct posix_acl	*i_acl;
	struct posix_acl	*i_default_acl;
#endif

	const struct inode_operations	*i_op;
	struct super_block	*i_sb;
	struct address_space	*i_mapping;

#ifdef CONFIG_SECURITY
	void			*i_security;
#endif

	/* Stat data, not accessed from path walking */
	unsigned long		i_ino;
	/*
	 * Filesystems may only read i_nlink directly.  They shall use the
	 * following functions for modification:
	 *
	 *    (set|clear|inc|drop)_nlink
	 *    inode_(inc|dec)_link_count
	 */
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t			i_rdev;
	loff_t			i_size;
	struct timespec64	i_atime;
	struct timespec64	i_mtime;
	struct timespec64	i_ctime;
	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
	unsigned short          i_bytes;
	u8			i_blkbits;
	u8			i_write_hint;
	blkcnt_t		i_blocks;

#ifdef __NEED_I_SIZE_ORDERED
	seqcount_t		i_size_seqcount;
#endif

	/* Misc */
	unsigned long		i_state;
	struct rw_semaphore	i_rwsem;

	unsigned long		dirtied_when;	/* jiffies of first dirtying */
	unsigned long		dirtied_time_when;

	struct hlist_node	i_hash;
	struct list_head	i_io_list;	/* backing dev IO list */
#ifdef CONFIG_CGROUP_WRITEBACK
	struct bdi_writeback	*i_wb;		/* the associated cgroup wb */

	/* foreign inode detection, see wbc_detach_inode() */
	int			i_wb_frn_winner;
	u16			i_wb_frn_avg_time;
	u16			i_wb_frn_history;
#endif
	struct list_head	i_lru;		/* inode LRU list */
	struct list_head	i_sb_list;
	struct list_head	i_wb_list;	/* backing dev writeback list */
	union {
		struct hlist_head	i_dentry;
		struct rcu_head		i_rcu;
	};
	atomic64_t		i_version;
	atomic64_t		i_sequence; /* see futex */
	atomic_t		i_count;
	atomic_t		i_dio_count;
	atomic_t		i_writecount;
#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)
	atomic_t		i_readcount; /* struct files open RO */
#endif
	union {
		const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context	*i_flctx;
	struct address_space	i_data;
	struct list_head	i_devices;
	union {
		struct pipe_inode_info	*i_pipe;
		struct cdev		*i_cdev;
		char			*i_link;
		unsigned		i_dir_seq;
	};

	__u32			i_generation;

#ifdef CONFIG_FSNOTIFY
	__u32			i_fsnotify_mask; /* all events this inode cares about */
	struct fsnotify_mark_connector __rcu	*i_fsnotify_marks;
#endif

#ifdef CONFIG_FS_ENCRYPTION
	struct fscrypt_info	*i_crypt_info;
#endif

#ifdef CONFIG_FS_VERITY
	struct fsverity_info	*i_verity_info;
#endif

	void			*i_private; /* fs or device private pointer */
} __randomize_layout;
\end{lstlisting}

\section{dentry}

\begin{lstlisting}
struct dentry {
	/* RCU lookup touched fields */
	unsigned int d_flags;		/* protected by d_lock */
	seqcount_spinlock_t d_seq;	/* per dentry seqlock */
	struct hlist_bl_node d_hash;	/* lookup hash list */
	struct dentry *d_parent;	/* parent directory */
	struct qstr d_name;
	struct inode *d_inode;		/* Where the name belongs to - NULL is
					 * negative */
	unsigned char d_iname[DNAME_INLINE_LEN];	/* small names */
	/* Ref lookup also touches following */
	struct lockref d_lockref;	/* per-dentry lock and refcount */
	const struct dentry_operations *d_op;
	struct super_block *d_sb;	/* The root of the dentry tree */
	unsigned long d_time;		/* used by d_revalidate */
	void *d_fsdata;			/* fs-specific data */
	union {
		struct list_head d_lru;		/* LRU list */
		wait_queue_head_t *d_wait;	/* in-lookup ones only */
	};
	struct list_head d_child;	/* child of parent list */
	struct list_head d_subdirs;	/* our children */
	/*
	 * d_alias and d_rcu can share memory
	 */
	union {
		struct hlist_node d_alias;	/* inode alias list */
		struct hlist_bl_node d_in_lookup_hash;	/* only for in-lookup ones */
	 	struct rcu_head d_rcu;
	} d_u;
} __randomize_layout;
\end{lstlisting}

\section{superblock}
\begin{lstlisting}
struct super_block {
  struct list_head	s_list;		/* Keep this first */
  dev_t			s_dev;		/* search index; _not_ kdev_t */
  unsigned char		s_blocksize_bits;
  unsigned long		s_blocksize;
  loff_t			s_maxbytes;	/* Max file size */
  struct file_system_type	*s_type;
  const struct super_operations	*s_op;
  const struct dquot_operations	*dq_op;
  const struct quotactl_ops	*s_qcop;
  const struct export_operations *s_export_op;
  unsigned long		s_flags;
  unsigned long		s_iflags;	/* internal SB_I_* flags */
  unsigned long		s_magic;
  struct dentry		*s_root;
  struct rw_semaphore	s_umount;
  int			s_count;
  atomic_t		s_active;
#ifdef CONFIG_SECURITY
  void                    *s_security;
#endif
  const struct xattr_handler **s_xattr;
#ifdef CONFIG_FS_ENCRYPTION
  const struct fscrypt_operations	*s_cop;
  struct fscrypt_keyring	*s_master_keys; /* master crypto keys in use */
#endif
#ifdef CONFIG_FS_VERITY
  const struct fsverity_operations *s_vop;
#endif
#ifdef CONFIG_UNICODE
  struct unicode_map *s_encoding;
  __u16 s_encoding_flags;
#endif
  struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */
  struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
  struct block_device	*s_bdev;
  struct backing_dev_info *s_bdi;
  struct mtd_info		*s_mtd;
  struct hlist_node	s_instances;
  unsigned int		s_quota_types;	/* Bitmask of supported quota types */
  struct quota_info	s_dquot;	/* Diskquota specific options */
  struct sb_writers	s_writers;
  void			*s_fs_info;	/* Filesystem private info */
  u32			s_time_gran;
  /* Time limits for c/m/atime in seconds */
  time64_t		   s_time_min;
  time64_t		   s_time_max;
#ifdef CONFIG_FSNOTIFY
  __u32			s_fsnotify_mask;
  struct fsnotify_mark_connector __rcu	*s_fsnotify_marks;
#endif
  char			s_id[32];	/* Informational name */
  uuid_t			s_uuid;		/* UUID */
  unsigned int		s_max_links;
  fmode_t			s_mode;
  struct mutex s_vfs_rename_mutex;	/* Kludge */
  const char *s_subtype;
  const struct dentry_operations *s_d_op; /* default d_op for dentries */
  int cleancache_poolid;
  struct shrinker s_shrink;	/* per-sb shrinker handle */
  atomic_long_t s_remove_count;
  atomic_long_t s_fsnotify_connectors;
  int s_readonly_remount;
  errseq_t s_wb_err;
  struct workqueue_struct *s_dio_done_wq;
  struct hlist_head s_pins;
  struct user_namespace *s_user_ns;
  struct list_lru		s_dentry_lru;
  struct list_lru		s_inode_lru;
  struct rcu_head		rcu;
  struct work_struct	destroy_work;
  struct mutex		s_sync_lock;	/* sync serialisation lock */
  int s_stack_depth;
  spinlock_t		s_inode_list_lock ____cacheline_aligned_in_smp;
  struct list_head	s_inodes;	/* all inodes */
  spinlock_t		s_inode_wblist_lock;
  struct list_head	s_inodes_wb;	/* writeback inodes */
} __randomize_layout;
\end{lstlisting}
\section{stat}
\begin{lstlisting}
struct stat {
  dev_t     st_dev;     /* ID of device containing file */
  ino_t     st_ino;     /* inode number */
  mode_t    st_mode;    /* protection */
  nlink_t   st_nlink;   /* number of hard links */
  uid_t     st_uid;     /* user ID of owner */
  gid_t     st_gid;     /* group ID of owner */
  dev_t     st_rdev;    /* device ID (if special file) */
  off_t     st_size;    /* total size, in bytes */
  blksize_t st_blksize; /* blocksize for file system I/O */
  blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
  time_t    st_atime;   /* time of last access */
  time_t    st_mtime;   /* time of last modification */
  time_t    st_ctime;   /* time of last status change */
};
\end{lstlisting}
